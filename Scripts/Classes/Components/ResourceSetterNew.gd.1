class_name ResourceSetterNew
extends Node

@export var node_to_affect: Node = null
@export var property_node: Node = null
@export var property_name := ""
@export var mode: ResourceMode = ResourceMode.SPRITE_FRAMES
@export var resource_json: JSON = null:
	set(value):
		resource_json = value
		update_resource()

enum ResourceMode {SPRITE_FRAMES, TEXTURE, AUDIO, RAW}
@export var use_cache := true

# existing caches (kept) + new caches
static var cache := {}                # legacy cache (keeps backward compatibility)
static var property_cache := {}
static var parsed_json_cache := {}    # caches parsed JSON for resource_path
static var resource_cache := {}       # caches final Resource objects (SpriteFrames/Textures/Audio)
# coalescing/batching
static var pending_updates := []
static var update_scheduled := false
const MAX_UPDATES_PER_BATCH := 4

var current_json_path := ""
static var state := [0, 0]
static var pack_configs := {}
var config_to_use := {}
var is_random := false
signal updated

@export var force_properties := {}
var update_on_spawn := true

func _init() -> void:
	set_process_mode(Node.PROCESS_MODE_ALWAYS)

func _ready() -> void:
	safety_check()
	if update_on_spawn:
		update_resource()
	Global.level_time_changed.connect(update_resource)
	Global.level_theme_changed.connect(update_resource)

func safety_check() -> void:
	if Settings.file.visuals.resource_packs.has("BaseAssets") == false:
		Settings.file.visuals.resource_packs.append("BaseAssets")

# ---- Updated: coalesced/batched update_resource() ----
func update_resource() -> void:
	# cheap early-outs
	if is_inside_tree() == false or is_queued_for_deletion() or resource_json == null or node_to_affect == null:
		return

	# if we already have the final Resource cached for this json_path, apply quickly (no heavy work)
	var rp := resource_json.resource_path
	if use_cache and force_properties.is_empty() and resource_cache.has(rp):
		if property_cache.has(rp):
			apply_properties(property_cache[rp])
		var quick_res = resource_cache[rp]
		node_to_affect.set(property_name, quick_res)
		if node_to_affect is AnimatedSprite2D:
			node_to_affect.play()
		updated.emit()
		return

	# coalesce heavy calls: push to shared queue and schedule processing in idle
	if not pending_updates.has(self):
		pending_updates.append(self)
	if not update_scheduled:
		update_scheduled = true
		call_deferred("_process_pending_updates")

func _process_pending_updates() -> void:
	update_scheduled = false
	var processed := 0
	while pending_updates.size() > 0 and processed < MAX_UPDATES_PER_BATCH:
		var rs = pending_updates[0]
		# remove first entry
		pending_updates.remove_at(0)
		if rs and rs.is_inside_tree() and not rs.is_queued_for_deletion():
			rs._perform_update_resource()
		processed += 1
	# if there are still pending updates, schedule next batch (keeps work spread over frames)
	if pending_updates.size() > 0:
		update_scheduled = true
		call_deferred("_process_pending_updates")

# This is the "real" update workload (moved from update_resource)
func _perform_update_resource() -> void:
	randomize()
	if is_inside_tree() == false or is_queued_for_deletion() or resource_json == null or node_to_affect == null:
		return
	# if theme/time changed, clear legacy caches (and our parsed/resource caches too)
	if state != [Global.level_theme, Global.theme_time]:
		cache.clear()
		property_cache.clear()
		parsed_json_cache.clear()
		resource_cache.clear()
	if node_to_affect != null:
		var resource = get_resource(resource_json)
		node_to_affect.set(property_name, resource)
		if node_to_affect is AnimatedSprite2D:
			node_to_affect.play()
	state = [Global.level_theme, Global.theme_time]
	updated.emit()

# ---- get_resource with parsed-json + resource caching ----
func get_resource(json_file: JSON) -> Resource:
	if json_file == null:
		return null
	var rp := json_file.resource_path
	# existing fast-cache check (kept) but prefer resource_cache
	if resource_cache.has(rp) and use_cache and force_properties.is_empty():
		if property_cache.has(rp):
			apply_properties(property_cache[rp])
		return resource_cache[rp]

	var resource: Resource = null
	var resource_path = rp
	config_to_use = {}
	for i in Settings.file.visuals.resource_packs:
		resource_path = get_resource_pack_path(resource_path, i)

	# parse JSON but cache the parsed result
	var source_json = null
	if parsed_json_cache.has(resource_path):
		source_json = parsed_json_cache[resource_path].duplicate()
	else:
		var f = FileAccess.open(resource_path, FileAccess.READ)
		if f == null:
			Global.log_error("Error opening " + resource_path + "!")
			return null
		source_json = JSON.parse_string(f.get_as_text())
		if source_json == null:
			Global.log_error("Error parsing " + resource_path + "!")
			return null
		# store a duplicate to be safe
		parsed_json_cache[resource_path] = source_json.duplicate()

	var json = source_json.duplicate()
	var source_resource_path := ""

	if json.has("variations"):
		json = get_variation_json(json.variations)
		if json.has("source"):
			if json.get("source") is String:
				source_resource_path = rp.replace(rp.get_file(), json.source)
		else:
			Global.log_error("Error getting variations! " + resource_path)
			return null

	for i in Settings.file.visuals.resource_packs:
		source_resource_path = get_resource_pack_path(source_resource_path, i)

	# Helper: cache key for spriteframes made from this json
	var spriteframes_key := rp + ":spriteframes"

	# If there's a rect/atlas
	if json.has("rect"):
		# load base atlas image (this may hit resource_cache)
		resource = load_image_from_path(source_resource_path)
		var atlas = AtlasTexture.new()
		atlas.atlas = resource
		atlas.region = Rect2(json.rect[0], json.rect[1], json.rect[2], json.rect[3])
		resource = atlas

	# apply properties
	if json.has("properties"):
		apply_properties(json.get("properties"))
		if use_cache:
			property_cache[rp] = json.properties.duplicate()
	elif source_json.has("properties"):
		apply_properties(source_json.get("properties"))
		if use_cache:
			property_cache[rp] = source_json.properties.duplicate()

	match mode:
		ResourceMode.SPRITE_FRAMES:
			var animation_json = {}
			if json.has("animations"):
				animation_json = json.get("animations")
			elif source_json.has("animations"):
				animation_json = source_json.get("animations")
			if animation_json != {}:
				# if we cached final SpriteFrames, reuse it
				if resource_cache.has(spriteframes_key):
					resource = resource_cache[spriteframes_key]
				else:
					var base_image = load_image_from_path(source_resource_path)
					# create atlas texture if needed
					if json.has("rect"):
						var atlas2 = AtlasTexture.new()
						atlas2.atlas = base_image
						atlas2.region = Rect2(json.rect[0], json.rect[1], json.rect[2], json.rect[3])
						base_image = atlas2
					resource = create_sprite_frames_from_image(base_image, animation_json)
					# cache spriteframes (unless random)
					if use_cache and not is_random:
						resource_cache[spriteframes_key] = resource
			else:
				# single frame spriteframes
				resource = load_image_from_path(source_resource_path)
				if json.has("rect"):
					var rect = json.rect
					var atlas3 = AtlasTexture.new()
					atlas3.atlas = resource
					atlas3.region = Rect2(rect[0], rect[1], rect[2], rect[3])
					resource = atlas3
				var sprite_frames = SpriteFrames.new()
				sprite_frames.add_frame("default", resource)
				resource = sprite_frames
				if use_cache and not is_random:
					resource_cache[rp] = resource
		ResourceMode.TEXTURE:
			if json.get("source") is Array:
				resource = AnimatedTexture.new()
				resource.frames = json.get("source").size()
				var idx := 0
				for i in json.get("source"):
					var frame_path = ResourceSetter.get_pure_resource_path(rp.replace(rp.get_file(), i))
					resource.set_frame_texture(idx, load_image_from_path(frame_path))
					idx += 1
			else:
				resource = load_image_from_path(source_resource_path)
			if json.has("rect"):
				var rect = json.rect
				var atlas = AtlasTexture.new()
				atlas.atlas = resource
				atlas.region = Rect2(rect[0], rect[1], rect[2], rect[3])
				resource = atlas
		ResourceMode.AUDIO:
			resource = load_audio_from_path(source_resource_path)
		ResourceMode.RAW:
			pass

	# final store in cache if allowed
	if resource_cache.has(rp) == false and use_cache and not is_random and resource != null:
		resource_cache[rp] = resource

	return resource

func apply_properties(properties := {}) -> void:
	if property_node == null:
		return
	for i in properties.keys():
		property_node.set(i, properties[i])

# get_variation_json left unchanged (keeps logic)

func get_variation_json(json := {}) -> Dictionary:
	# ... (same as your original)
	# I left this function intact to preserve your variation logic.
	# (omitted here for brevity in this snippet block â€” keep your original)
	return json

func get_resource_pack_path(res_path := "", resource_pack := "") -> String:
	var user_path := res_path.replace("res://Assets", "user://resource_packs/" + resource_pack)
	user_path = user_path.replace("user://custom_characters/", "user://resource_packs/" + resource_pack + "/Sprites/Players/CustomCharacters/")
	if FileAccess.file_exists(user_path):
		if FileAccess.file_exists("user://resource_packs/" + resource_pack + "/config.json"):
			config_to_use = JSON.parse_string(FileAccess.open("user://resource_packs/" + resource_pack + "/config.json", FileAccess.READ).get_as_text())
			if config_to_use == null:
				Global.log_error("Error parsing Config File! (" + resource_pack + ")")
				config_to_use = {}
		return user_path
	else:
		return res_path

func create_sprite_frames_from_image(image: Resource, animation_json := {}) -> SpriteFrames:
	# Build SpriteFrames once and return.
	var sprite_frames = SpriteFrames.new()
	sprite_frames.remove_animation("default")
	for anim_name in animation_json.keys():
		sprite_frames.add_animation(anim_name)
		for frame in animation_json[anim_name].frames:
			var frame_texture = AtlasTexture.new()
			frame_texture.atlas = image
			frame_texture.region = Rect2(frame[0], frame[1], frame[2], frame[3])
			frame_texture.filter_clip = true
			sprite_frames.add_frame(anim_name, frame_texture)
		sprite_frames.set_animation_loop(anim_name, animation_json[anim_name].loop)
		sprite_frames.set_animation_speed(anim_name, animation_json[anim_name].speed)
	return sprite_frames

func clear_cache() -> void:
	# clear everything
	cache.clear()
	property_cache.clear()
	parsed_json_cache.clear()
	resource_cache.clear()

func log(message) -> void:
	var millis = int(Time.get_unix_time_from_system()*1000) - 1759860000000;
	var string = "at %f happened: " + message
	print(string % millis)

func load_image_from_path(path := "") -> ImageTexture:
	if path == "":
		return null
	if path.find("res://") != -1:
		if path.find("NULL") != -1:
			return null
		# prefer ResourceLoader.load for engine resources (it uses engine caching)
		return ResourceLoader.load(path)
	# user:// or absolute path: cache ImageTexture creation
	if resource_cache.has(path):
		return resource_cache[path]
	var image = Image.new()
	var err = image.load(path)
	if err != OK:
		Global.log_error("Failed to load image: " + path)
		return null
	var tex = ImageTexture.create_from_image(image)
	resource_cache[path] = tex
	return tex

func load_audio_from_path(path := "") -> AudioStream:
	if path == null:
		return null
	if path.find("res://") != -1:
		return ResourceLoader.load(path)
	var stream = null
	if path.find(".wav") != -1:
		stream = AudioStreamWAV.load_from_file(path)
	elif path.find(".mp3") != -1:
		stream = AudioStreamMP3.load_from_file(path)
	return stream
